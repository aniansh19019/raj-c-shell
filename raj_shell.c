#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>
#include<sys/wait.h>
#include <sys/utsname.h>

void cyan()
{
    printf("\033[1;36m"); // red color
}

void red()
{
    printf("\033[1;31m"); // red color
}
void normal()
{
    printf("\033[0m");
}

// Number of commands stored in history
#define HISTORY_BUFFER_SIZE 128

// size in bytes of the command strings
#define COMMAND_SIZE 1024

// number of arguments allowed in one command
#define NUM_ARGUMENTS 16

// size in bytes of one argument
#define ARGUMENT_SIZE 64

// maximum size of a directory name in bytes
#define DIRECTORY_SIZE 1024

//maximum number of paths
#define MAX_NUM_PATHS 64


const char prompt_suffix[] = "->> \0";

char history[HISTORY_BUFFER_SIZE][COMMAND_SIZE]; //* Storing commands history
unsigned int history_index=0; //* for storing command history

short int loopback=0; //* to see if the command history buffer has rolled back or not

char PWD[DIRECTORY_SIZE]; //* to store environment PWD

// char* PATH[NUM_ARGUMENTS]={"/usr/bin/", "/bin/", "/usr/local/bin", "/sbin/", "/usr/sbin/", "/usr/local/sbin"}; 
char* PATH[NUM_ARGUMENTS];
//* to store bin PATH

int custom_path=0; //* set to 1 if using custom PATH


//* prototypes

int loop();
void test();
void save_to_history(char command[]);
void print_prompt();
unsigned int get_history_index();

int parse_command(char command[]);
void init_args(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]);

int command_handler(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE], int num_arguments);

//* internal commands
void echo_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]); // echo
void echo_command_no_newline(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]); // echo -n
void echo_command_no_escape(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]); // echo -E

void cd_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]); // cd  and cd -L
//* cd . cd ..  cd ~ implemeneted relative, absolute, home relative
void cd_command_physical(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]); // cd -P

void pwd_command(); // pwd -P and pwd
void pwd_command_env(); // pwd -L

void history_command(); //history
void history_command_number(int n); //history [n]
void history_command_clear(); //history -c
void history_command_exec(int n);// \! n

void exit_command();
void exit_command_code(int exit_code);
void parse_environment_path();

//* external commands handler
int external_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE], int num_arguments);

void print_logo()
{
    char logo[] = {0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x2E, 0x3B, 0x3D, 0x3D, 0x3D, 0x2B, 0x2E, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x3A, 0x3D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x3D, 0x2B, 0x3D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x3D, 0x69, 0x29, 0x29, 0x3D, 0x3B, 0x3A, 0x3A, 0x2B, 0x29, 0x69, 0x3D, 0x2B, 0x2C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x3D, 0x69, 0x29, 0x3B, 0x29, 0x49, 0x29, 0x29, 0x29, 0x49, 0x29, 0x3A, 0x3D, 0x69, 0x3D, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x3D, 0x69, 0x3D, 0x3D, 0x29, 0x29, 0x29, 0x29, 0x69, 0x69, 0x29, 0x29, 0x29, 0x49, 0x3A, 0x69, 0x2B, 0x2B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x29, 0x2B, 0x29, 0x29, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x29, 0x29, 0x49, 0x3D, 0x69, 0x2B, 0x3A, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x2C, 0x3A, 0x3B, 0x3B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x3B, 0x3A, 0x2C, 0x2E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x29, 0x69, 0x69, 0x69, 0x2B, 0x3A, 0x3A, 0x3A, 0x3B, 0x69, 0x69, 0x69, 0x29, 0x29, 0x2B, 0x69, 0x3D, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x3A, 0x3B, 0x2B, 0x2B, 0x3D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x3D, 0x2B, 0x2B, 0x3B, 0x2E, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x3A, 0x3A, 0x2C, 0x2C, 0x2C, 0x3A, 0x3A, 0x3A, 0x3D, 0x69, 0x29, 0x29, 0x3B, 0x3D, 0x2B, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x3B, 0x2B, 0x3D, 0x3D, 0x69, 0x69, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x69, 0x69, 0x3D, 0x3D, 0x2B, 0x3B, 0x2C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x2C, 0x2C, 0x3A, 0x3D, 0x69, 0x29, 0x29, 0x2B, 0x3D, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x3B, 0x2B, 0x3D, 0x69, 0x69, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x29, 0x29, 0x29, 0x29, 0x69, 0x69, 0x3D, 0x3D, 0x3D, 0x3B, 0x2E, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x2C, 0x3A, 0x3D, 0x69, 0x29, 0x3D, 0x69, 0x2B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3B, 0x2B, 0x3D, 0x69, 0x69, 0x29, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x54, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x29, 0x29, 0x29, 0x29, 0x69, 0x69, 0x69, 0x69, 0x3D, 0x2B, 0x2C, 0x20, 0x20, 0x20, 0x2C, 0x3A, 0x3D, 0x29, 0x29, 0x3B, 0x3D, 0x2C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x2B, 0x3D, 0x69, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x54, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x29, 0x29, 0x29, 0x49, 0x29, 0x69, 0x3D, 0x2B, 0x2C, 0x2C, 0x3A, 0x2B, 0x69, 0x29, 0x3D, 0x69, 0x2B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x2B, 0x69, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x29, 0x29, 0x69, 0x3D, 0x3A, 0x3A, 0x69, 0x29, 0x29, 0x69, 0x3D, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x3D, 0x69, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x54, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x49, 0x29, 0x2B, 0x3B, 0x2B, 0x69, 0x29, 0x2B, 0x69, 0x60, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x69, 0x29, 0x29, 0x49, 0x49, 0x49, 0x54, 0x54, 0x4C, 0x54, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x54, 0x54, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x49, 0x49, 0x2B, 0x3A, 0x69, 0x29, 0x69, 0x69, 0x3A, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x69, 0x29, 0x29, 0x49, 0x49, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x2B, 0x3A, 0x69, 0x29, 0x29, 0x29, 0x3D, 0x2C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x29, 0x29, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x54, 0x69, 0x3A, 0x3D, 0x29, 0x49, 0x49, 0x69, 0x69, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x69, 0x29, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x54, 0x49, 0x54, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x54, 0x29, 0x3B, 0x3D, 0x29, 0x49, 0x29, 0x29, 0x29, 0x29, 0x29, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x29, 0x29, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x48, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x29, 0x3B, 0x3D, 0x29, 0x49, 0x49, 0x29, 0x49, 0x49, 0x49, 0x49, 0x69, 0x3D, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x69, 0x29, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x48, 0x4C, 0x4C, 0x48, 0x4C, 0x4C, 0x29, 0x2B, 0x3D, 0x29, 0x49, 0x49, 0x29, 0x49, 0x54, 0x54, 0x54, 0x49, 0x29, 0x69, 0x3D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x69, 0x29, 0x49, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x49, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x48, 0x48, 0x4C, 0x4C, 0x4C, 0x4C, 0x29, 0x3B, 0x3D, 0x29, 0x49, 0x49, 0x29, 0x49, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x29, 0x69, 0x2B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x69, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x48, 0x4C, 0x4C, 0x3D, 0x3A, 0x69, 0x29, 0x49, 0x49, 0x29, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x49, 0x29, 0x69, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x69, 0x29, 0x69, 0x29, 0x29, 0x29, 0x49, 0x49, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x54, 0x3D, 0x3A, 0x69, 0x29, 0x49, 0x49, 0x29, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x49, 0x49, 0x49, 0x29, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x69, 0x69, 0x29, 0x69, 0x3A, 0x29, 0x49, 0x49, 0x54, 0x54, 0x4C, 0x4C, 0x54, 0x4C, 0x4C, 0x4C, 0x4C, 0x54, 0x3D, 0x3B, 0x2B, 0x69, 0x29, 0x49, 0x29, 0x49, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x54, 0x49, 0x49, 0x29, 0x29, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0x3B, 0x29, 0x69, 0x3D, 0x3A, 0x2C, 0x3D, 0x29, 0x49, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x54, 0x54, 0x49, 0x3D, 0x3A, 0x69, 0x29, 0x29, 0x49, 0x29, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x29, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x69, 0x29, 0x69, 0x69, 0x3A, 0x3A, 0x2C, 0x20, 0x20, 0x2B, 0x29, 0x49, 0x49, 0x49, 0x54, 0x49, 0x2B, 0x3A, 0x2B, 0x69, 0x29, 0x49, 0x29, 0x29, 0x54, 0x54, 0x54, 0x54, 0x4C, 0x4C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x29, 0x29, 0x3D, 0x2C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x3D, 0x3B, 0x29, 0x69, 0x3D, 0x3A, 0x2C, 0x2C, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x69, 0x2B, 0x2B, 0x3A, 0x3A, 0x69, 0x29, 0x29, 0x49, 0x29, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x49, 0x49, 0x29, 0x3D, 0x2B, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2E, 0x2B, 0x69, 0x69, 0x29, 0x69, 0x3D, 0x3A, 0x3A, 0x2C, 0x2C, 0x20, 0x20, 0x20, 0x2C, 0x2C, 0x3A, 0x3A, 0x3D, 0x69, 0x29, 0x29, 0x29, 0x69, 0x49, 0x49, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x49, 0x49, 0x49, 0x49, 0x49, 0x29, 0x3D, 0x2B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x3D, 0x3D, 0x29, 0x69, 0x69, 0x3D, 0x3B, 0x3A, 0x2C, 0x2C, 0x2C, 0x2C, 0x3A, 0x3A, 0x3A, 0x3D, 0x69, 0x69, 0x29, 0x69, 0x29, 0x69, 0x49, 0x49, 0x49, 0x49, 0x54, 0x49, 0x49, 0x49, 0x54, 0x49, 0x49, 0x49, 0x49, 0x29, 0x29, 0x69, 0x2B, 0x3A, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2B, 0x3D, 0x3A, 0x29, 0x29, 0x69, 0x3D, 0x3D, 0x3B, 0x3A, 0x3A, 0x3A, 0x3B, 0x3D, 0x69, 0x69, 0x69, 0x29, 0x2B, 0x29, 0x3D, 0x20, 0x20, 0x60, 0x3A, 0x69, 0x29, 0x29, 0x29, 0x49, 0x49, 0x49, 0x49, 0x49, 0x29, 0x69, 0x69, 0x2B, 0x27, 0x0A, 0x20, 0x20, 0x20, 0x2E, 0x2B, 0x3D, 0x3A, 0x29, 0x29, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x29, 0x29, 0x29, 0x2B, 0x69, 0x69, 0x3B, 0x0A, 0x20, 0x20, 0x2E, 0x2B, 0x3D, 0x3B, 0x29, 0x29, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x29, 0x29, 0x29, 0x3B, 0x69, 0x69, 0x2B, 0x0A, 0x20, 0x2E, 0x2B, 0x3D, 0x69, 0x3A, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x3D, 0x2B, 0x69, 0x69, 0x2B, 0x0A, 0x2E, 0x3B, 0x3D, 0x3D, 0x69, 0x2B, 0x3A, 0x3A, 0x3A, 0x3A, 0x3D, 0x29, 0x69, 0x3D, 0x3B, 0x0A, 0x2C, 0x2B, 0x3D, 0x3D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x2B, 0x2C, 0x0A, 0x60, 0x2B, 0x3D, 0x2B, 0x2B, 0x2B, 0x3B, 0x60, 0x0};
    printf("\033[1;36m"); // cyan color
    puts(logo);
    puts("\n\nWelcome to Raj Shell!\nWritten in C by Aniansh Raj Singh\n2019019\n");
    //reset color
    printf("\033[0m");
}

int main(int argc, char **argv)
{
    if(argc == 2)
    {
        if(*(*(argv+1)) == '1')
        {
            custom_path=1;
        }
        else if(*(*(argv+1)) == '0')
        {
            custom_path=0;
        }
        else
        {
            puts("Invalid Argument!");
            exit(-1);
        }
    }
    else
    {
        custom_path=1; // default to using environment path
    }
    
    parse_environment_path(); // get $PATH variable and load all paths
    loop();
}


int loop()
{
    //one time code
    printf("\e[1;1H\e[2J"); // one time clear screen
    print_logo();
    printf("\n\n\n"); 

    //*
    strcpy(PWD, getenv("PWD")); // initialise PWD

    parse_environment_path();

    while(1)
    {

        print_prompt();
        char next_char;
        char command[COMMAND_SIZE]; //* Allow a max command of 1024 bytes
        unsigned command_index=0;


        do
        {
            next_char = getc(stdin);

            switch(next_char)
            {
                case 8://* Backspace
                    command_index--; // erase character from command
                    if(command_index<0)
                    {
                        command_index=0;//error handling
                    }
                    break;

                case 10: //* Enter
                    command[command_index++] = '\0'; // insert null terminator
                    break;

                default: //* other characters
                    command[command_index++] = next_char; // store next character to command
                    break;
            }

        } while (next_char!='\n'); //* Waiting for enter key

        //* After Entering the command

        save_to_history(command); // save to rolling history buffer

        parse_command(command); // send command to be parsed and executed


        
    }
    return 0;
}



void save_to_history(char command[])
{
    unsigned int next_index = get_history_index(); //get index to store into command_history

    for(int i=0; i<COMMAND_SIZE; i++)
    {
        history[next_index][i] = command[i]; // copy command to history rolling buffer
    }
}

int is_physical=0;

void print_prompt()
{
    // set color
    
    cyan();

    char username[DIRECTORY_SIZE];
    char hostname[DIRECTORY_SIZE];

    

    
    //retrieve username
    getlogin_r(username, DIRECTORY_SIZE);

    //retrieve hostname
    gethostname(hostname, DIRECTORY_SIZE);


    printf("\033[1;32m"); // green color

    // print user@host
    printf("%s@%s", username, hostname);
    normal();
    printf(":");

    cyan(); //cyan color
    

    char working_directory[DIRECTORY_SIZE];
    char* home_dir;
    if(is_physical)
    {
        getcwd(working_directory, DIRECTORY_SIZE);
    }
    else
    {
        strcpy(working_directory, PWD);
    }
    
    //*
    
    home_dir = getenv("HOME");

    char relative_dir[DIRECTORY_SIZE];

    int cwd_index=0;
    int cwd_len=strlen(working_directory);
    int home_len = strlen(home_dir);

    while(cwd_index<cwd_len && cwd_index<home_len && working_directory[cwd_index] == home_dir[cwd_index])
    {
        cwd_index++;
    }

    if(cwd_index<home_len) // cwd is outside the home
    {
        printf("%s",working_directory);
    }
    else if(cwd_len==home_len)
    {
        printf("~/");
    }
    else 
    {
        strcpy(relative_dir, "~\0");
        strcat(relative_dir, working_directory+cwd_index);
        printf("%s", relative_dir);
    }
    

    printf("\033[1;32m"); // green color
    printf("%s", prompt_suffix);


    //reset color
    printf("\033[0m");
}



unsigned int get_history_index()
{
    unsigned int retval = history_index;
    history_index++;
    if(history_index>=HISTORY_BUFFER_SIZE)//check for rollback
    {
        loopback=1;
    }
    history_index%=HISTORY_BUFFER_SIZE;
    return retval;
}




int parse_command(char command[])
{
    char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE];//for storing split strings
    int arguments_index=0; // for indexing arguments

    init_args(arguments); // clear the arguments array of garbage values

    int command_index=0;// for indexing individual characters from command
    char argument[ARGUMENT_SIZE]; // for storing individual arguments while parsing
    int arg_index=0; //for storing in argument char array


    char next_char; // for storing next character read

    do
    {
        next_char=command[command_index++]; // retrieve next character
        if(next_char==' ' || next_char == '\0') //if end of word
        {
            argument[arg_index++] = '\0';   //null terminator
            arg_index=0; // reset arg index
            strcpy(arguments[arguments_index++], argument); // copy to arguments array
        }
        else
        {
            argument[arg_index++] = next_char; // append next character
        }
        

    } while (next_char!='\0');

    //* command split at spaces and stored in arguments

    return command_handler(arguments, arguments_index);
}


int is_number(char numstr[])
{
    int num=atoi(numstr);
    if(num==0 && numstr[0]!='0')
    {
        return 0;
    }
    
    return 1;
}





int command_handler(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE], int num_arguments)
{
    if(!strcmp(arguments[0],"clear\0"))
    {
        printf("\e[1;1H\e[2J"); // one time clear screen
    }
    else if(!strcmp(arguments[0],"history\0"))
    {
        if(!strcmp(arguments[1], "-c")) // clear flag is used
        {
            history_command_clear();
        }
        else if(is_number(arguments[1])) // number is entered as argument
        {
            history_command_number(atoi(arguments[1]));
        }
        else if(arguments[1][0] == '\0')
        {
            history_command(); // normal history without any options
        }
        else
        {
            red();
            puts("Invalid option for command: history\0"); // error handling
            normal();
        }
        
    }
    else if(!strcmp(arguments[0], "echo\0"))
    {
        if(!strcmp(arguments[1], "-n\0")) // echo -n
        {
            echo_command_no_newline(arguments);
        }
        else if(!strcmp(arguments[1], "-E\0")) // echo -E
        {
            echo_command_no_escape(arguments);// echo -E
        }
        else if(arguments[1][0] == '-') // some other flag
        {
            puts("Invalid Option for echo!");
        }
        else // echo
        {
            echo_command(arguments); 
        }
        
    }
    else if(!strcmp(arguments[0], "pwd\0"))
    {
        if(arguments[1][0] == '\0') // pwd
        {
            pwd_command_env();
        }
        else if(!strcmp(arguments[1], "-L\0")) // pwd -L
        {
            pwd_command_env();
        }
        else if(!strcmp(arguments[1], "-P\0")) // pwd -P
        {
            pwd_command();
        }
        else
        {
            red();
            puts("Invalid option for command: pwd\0"); // error handling
            normal();
        }
        
    }
    else if(!strcmp(arguments[0], "cd\0"))
    {
        if(!strcmp(arguments[1], "-L\0")) // pwd -L
        {
            cd_command(arguments+1);
        }
        else if(!strcmp(arguments[1], "-P\0")) // pwd -P
        {
            cd_command_physical(arguments+1);
        }
        else if(arguments[1][0] == '-')
        {
            red();
            puts("Invalid option for command: cd\0"); // error handling
            normal();
        }
        else
        {
            cd_command(arguments);
        }
        
    }
    else if(!strcmp(arguments[0], "exit\0"))
    {
        if(is_number(arguments[1]))
        {
            exit_command_code(atoi(arguments[1]));
        }
        else if(arguments[1][0]=='\0')
        {
            exit_command();
        }
        else
        {
            red();
            puts("Invalid option for command: exit"); // error handling 
            normal();
        }
        
    }
    else if(arguments[0][0] == '!')
    {
        if(is_number(arguments[0]+1))
        {
            history_command_exec(atoi(arguments[0]+1));
        }
        else
        {
            red();
            puts("Invalid option for command: !"); // error handling 
            normal();
        }
        
    }
    else
    {
        return external_command(arguments, num_arguments);
    }

    return 1;
    
}

void parse_environment_path() // Get $PATH environment variable and populate the PATH variable list
{
    char* all_paths = getenv("PATH");
    // puts(all_paths);

    // char arguments[NUM_ARGUMENTS][2048];//for storing split strings
    int arguments_index=0; // for indexing arguments

    // init_args(arguments); // clear the arguments array of garbage values

    int command_index=0;// for indexing individual characters from command
    char argument[2048]; // for storing individual arguments while parsing
    int arg_index=0; //for storing in argument char array


    char next_char; // for storing next character read

    do
    {
        next_char= *(all_paths + command_index); // retrieve next character
        command_index++;

        if(next_char==':' || next_char == '\0') //if end of word
        {
            argument[arg_index++] = '/'; //append '/'
            argument[arg_index++] = '\0';   //null terminator
            arg_index=0; // reset arg index
            PATH[arguments_index] = malloc(2048);
            strcpy(PATH[arguments_index++], argument); // copy to PATH array
        }
        else
        {
            argument[arg_index++] = next_char; // append next character
        }
        

    } while (next_char!='\0');
    
}


int external_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE], int num_arguments)
{
    int result = fork();
    

    if(result==0)
    {
        int index = 0;
        int got_error;
        do
        {
            char path[DIRECTORY_SIZE];
            strcpy(path, getenv("PWD\0"));

            if(custom_path)
            {
                strcpy(path, PATH[index]);//* if path is provided
            }
            else
            {
                strcat(path, "/bin/\0");//* if path not provided
            }

            strcat(path, arguments[0]);

            char * argv[NUM_ARGUMENTS]; // prepping for execv
            for(int i=0; i<num_arguments; i++)
            {
                argv[i] = arguments[i];
            }

            argv[num_arguments] = NULL;

            got_error = execv(path, argv);

            index++;

        }while(got_error && errno == ENOENT && custom_path && index < NUM_ARGUMENTS);
        puts("exited!");
        red();
        printf("%d",got_error);
        if(got_error) // if received error!
        {
            switch(errno)
            {
                case EFAULT:
                    puts("Error! Bad Address!");
                    break;
                case ENOENT:
                    puts("Command not found!");
                    break;
                case EACCES:
                    puts("permission denied!");
                    break;
                default:
                    puts("Unexpected Error occured!");
            }
        }
        normal();
        exit(0); // exit child process
    }
    else if(result>0)
    {
        int status;
        waitpid(result, &status, 0);
    }
    else
    {
        red();
        puts("Unexpected error occured!\n Could not fork!");
        normal();
    }
    
    return 1;
}





void init_args(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE]) //* clear the arguments array
{
    for(int i=0; i<NUM_ARGUMENTS; i++)
    {
        for(int j=0; j<ARGUMENT_SIZE; j++)
        {
            arguments[i][j] = '\0';
        }
    }
}


//TODO implement options


//TODO implement up and down key action


//* History commands begin
void history_command()
{
    if(loopback) // if the buffer has rolled over at least once
    {
        for(int i=history_index; i<HISTORY_BUFFER_SIZE; i++)
        {
            printf("%d \t", i);
            puts(history[i]); // print all commands in the order they were entered
        }
    }

    for(int i=0; i<history_index; i++)
    {
        printf("%d \t", i);
        puts(history[i]); // print all commands in the order they were entered
    }
    
}


void history_command_number(int n)
{
    int indices[HISTORY_BUFFER_SIZE]; // to save indices to be displayed
    int temp_index=0; // indices array index

    int counter=0;
    int i=history_index-1;

    while(counter<n && i>=0)
    {
        indices[temp_index++] = i--; // store index in array
        counter++;
    }

    if(loopback)
    {
        int i=HISTORY_BUFFER_SIZE-1;
        while(counter<n && i>=history_index)
        {
            indices[temp_index++] = i--; // store index in array
            counter++;
        }
    }

    for(i=temp_index-1; i>=0; i--)
    {
        printf("%d \t", indices[i]);
        puts(history[indices[i]]);// display all data in the correct order
    }
    

    
}

void history_command_clear()
{
    history_index=0; //set index to 0
    loopback=0; // set loopback to 0
}


void history_command_exec(int n)
{
    int is_valid=1;

    if(n<0)
    {
        is_valid=0;
    }

    if(loopback)
    {
        if(n>=HISTORY_BUFFER_SIZE || n == history_index-1)
        {
            is_valid=0;
        }
    }
    else
    {
        if(n>=history_index-1)
        {
            is_valid=0;
        }
    }

    if(history[n][0] == '!') // cannot call itself
    {
        is_valid=0;
    }

    if(!is_valid) // error handling
    {
        red();
        puts("Invalid argument for !");
        normal();
        return;
    }

    parse_command(history[n]);

    
}

// * History commands end


//* Echo command begins
void echo_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE])
{
    int i=1; // skipping only the first argument
    while(arguments[i][0]!='\0') // print until a null argument is encountered
    {
        printf("%s ", arguments[i++]);
    }
    printf("\n");// newline for end
}

void echo_command_no_newline(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE])
{
    int i=2; // skipping the second argument as well
    while(arguments[i][0]!='\0') // print until a null argument is encountered
    {
        printf("%s ", arguments[i++]);
    }
}

void echo_command_no_escape(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE])
{
    echo_command_no_newline(arguments);
    printf("\n");
}

//* echo command ends

//* exit command begins
void exit_command()
{
    printf("\033[1;36m"); // cyan color

    puts("\n\nThank you for using raj shell :)");
    puts("Exiting...");
    printf("\033[0m");

    exit(0);
}

void exit_command_code(int exit_code)
{
    printf("\033[1;36m"); // cyan color

    puts("\n\nThank you for using raj shell :)");
    puts("Exiting...");
    printf("\033[0m");

    exit(exit_code);
}

//* exit command ends


//* pwd command starts
void pwd_command()
{
    char working_directory[DIRECTORY_SIZE];
    getcwd(working_directory, DIRECTORY_SIZE);
    puts(working_directory);
}

void pwd_command_env()
{
    puts(PWD);
}
//* pwd command ends

//* cd command starts


void reduce_pwd()
{
    int n= strlen(PWD);
    int i=n-1;
    while(i>=0 && PWD[i]!='/')
    {
        i--;
    }

    PWD[i]='\0';//null terminate


    if(!strcmp(PWD, "\0")) // if root
    {
        strcpy(PWD, "/\0");
    }
    
    
    
}


// Logical
void cd_command(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE])
{
    is_physical=0; // set for prompt

    int got_error=0; //error code for cd

    char path_with_spaces[DIRECTORY_SIZE];

    int dir_index=0;

    int i=2;

    strcpy(path_with_spaces, arguments[1]);

    while(arguments[i][0]!='\0' && i<NUM_ARGUMENTS) // dealing with spaces in the path
    {
        strcat(path_with_spaces, " \0");
        strcat(path_with_spaces, arguments[i++]);
    }

    // Entire path in path_with_spaces

    if(arguments[1][0]=='\0') // if no arguments present
    {
        got_error = chdir(getenv("HOME"));
        if(!got_error)
            strcpy(PWD, getenv("HOME"));
    }
    else if(arguments[1][0]=='/') // absolute path
    {
        got_error = chdir(path_with_spaces);
        //*
        if(!got_error)
            strcpy(PWD, path_with_spaces);
        

    }
    else if(arguments[1][0]=='~')
    {
        char absolute_dir[DIRECTORY_SIZE];
        strcpy(absolute_dir, getenv("HOME")); //get home directory

        int home_length = strlen(absolute_dir); // length of home path
        
        strcat(absolute_dir, path_with_spaces+1); // skipping ~

        got_error = chdir(absolute_dir);
        //*
        if(!got_error)
            strcpy(PWD, absolute_dir);
    }
    else if(!strcmp(arguments[1], "..\0"))
    {
        reduce_pwd();
        got_error = chdir(PWD);
    }
    else if(!strcmp(arguments[1], ".\0"))
    {
        got_error=chdir(PWD);
    }
    else
    {
        //relative to current working directory
        char absolute_dir[DIRECTORY_SIZE];

        getcwd(absolute_dir, DIRECTORY_SIZE);

        int cwd_index = strlen(absolute_dir); // length of home path

        absolute_dir[cwd_index++] = '/'; // slash
        absolute_dir[cwd_index++] = '\0'; // null terminator

        strcat(absolute_dir, path_with_spaces);// combine paths

        got_error = chdir(absolute_dir);
        //*
        if(!got_error)
            strcpy(PWD, absolute_dir);

    }

    if(got_error) // error handling
    {
        red();
        switch(errno)
        {
            case EACCES:
                puts("Permission Denied!\0");
                break;
            case ENOENT:
                puts("Invalid Path!\0");
                break;
            case ENOTDIR:
                puts("Not a directory!\0");
                break;
            default:
                puts("Unexpected error!\0");
        }
        normal();
    }

    
    

}

void cd_command_physical(char arguments[NUM_ARGUMENTS][ARGUMENT_SIZE])
{
    is_physical=1; // set for prompt

    int got_error=0; //error code for cd

    char path_with_spaces[DIRECTORY_SIZE];

    int dir_index=0;

    int i=2;

    strcpy(path_with_spaces, arguments[1]);

    while(arguments[i][0]!='\0' && i<NUM_ARGUMENTS) // dealing with spaces in the path
    {
        strcat(path_with_spaces, " \0");
        strcat(path_with_spaces, arguments[i++]);
    }

    // Entire path in path_with_spaces

    if(arguments[1][0]=='\0') // if no arguments present
    {
        got_error = chdir(getenv("HOME"));
        if(!got_error)
            strcpy(PWD, getenv("HOME"));
    }
    else if(arguments[1][0]=='/') // absolute path
    {
        got_error = chdir(path_with_spaces);
        //*
        if(!got_error)
            strcpy(PWD, path_with_spaces);
        

    }
    else if(arguments[1][0]=='~')
    {
        char absolute_dir[DIRECTORY_SIZE];
        strcpy(absolute_dir, getenv("HOME")); //get home directory

        int home_length = strlen(absolute_dir); // length of home path
        
        strcat(absolute_dir, path_with_spaces+1); // skipping ~

        got_error = chdir(absolute_dir);
        //*
        if(!got_error)
            strcpy(PWD, absolute_dir);
    }
    else
    {
        //relative to current working directory
        char absolute_dir[DIRECTORY_SIZE];

        getcwd(absolute_dir, DIRECTORY_SIZE);

        int cwd_index = strlen(absolute_dir); // length of home path

        absolute_dir[cwd_index++] = '/'; // slash
        absolute_dir[cwd_index++] = '\0'; // null terminator

        strcat(absolute_dir, path_with_spaces);// combine paths

        got_error = chdir(absolute_dir);
        //*

        if(!got_error)
        {
            if(!strcmp(arguments[1], "..\0"))
            {
                reduce_pwd();
            }
            else if(!strcmp(arguments[1], ".\0"))
            {
                //nothing
            }
            else
            {
                strcpy(PWD, absolute_dir);
            }
        }
    }

    if(!got_error)
    {
        getcwd(PWD, DIRECTORY_SIZE);
    }

    

    if(got_error) // error handling
    {
        red();
        switch(errno)
        {
            case EACCES:
                puts("Permission Denied!\0");
                break;
            case ENOENT:
                puts("Invalid Path!\0");
                break;
            case ENOTDIR:
                puts("Not a directory!\0");
                break;
            default:
                puts("Unexpected error!\0");
        }
        normal();
    }
}

//* cd command ends
